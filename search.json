[{"path":"https://jtr13.github.io/annotreer/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 annotreer authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jtr13.github.io/annotreer/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"First Last. Author, maintainer.","code":""},{"path":"https://jtr13.github.io/annotreer/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Last F (2025). annotreer: Package (One Line, Title Case). R package version 0.0.0.9000, https://github.com/jtr13/annotreer.","code":"@Manual{,   title = {annotreer: What the Package Does (One Line, Title Case)},   author = {First Last},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://github.com/jtr13/annotreer}, }"},{"path":"https://jtr13.github.io/annotreer/index.html","id":"annotreer","dir":"","previous_headings":"","what":"What the Package Does (One Line, Title Case)","title":"What the Package Does (One Line, Title Case)","text":"package provides one function, annotree(), wrapper rpart.plot::prp(). employing customized labeling functions hood, annotree() helps us visualize complexity parameter calculations. annotations helpful explaining CART’s pruning algorithm.","code":""},{"path":"https://jtr13.github.io/annotreer/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"What the Package Does (One Line, Title Case)","text":"Install :","code":"remotes::install_github(\"jtr13/annotreer\")"},{"path":"https://jtr13.github.io/annotreer/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"What the Package Does (One Line, Title Case)","text":"ever create classification tree rpart, view cptable returned wonder columns calculated? package creates custom label functions calls rpart.plot::prp() create tree diagrams aid understanding table summarizes pruning options. Let’s start example. create large tree rpart::rpart() visualize annotree(). data rpart package: Kyphosis – type deformation absent present surgery Age – months Number – number vertebrae involved Start – number first (topmost) vertebra operated goal classify Kyphosis variable based Age, Number Start. setting parameter show_classes = TRUE call annotree() , nodes labeled class labels class counts.  Since set parameters rpart() grow large tree possible, deviance leaf nodes zero: every leaf node zero one classes. can make deviance leaves explict setting show_leaf_dev TRUE:  Now turn pruning process. rpart() returns cptable provides pruning options. Following cost complexity pruning algorithm CART (see Breiman, et al. 1984) table show every possible subtree, ones produced sequentially pruning next weakest link tree reduced single node. particular case, given 6 options shown nsplit column: 0, 1, 2, 5, 10, 16 splits. larger subtrees contains smaller ones, ’ll see get details pruning process. CP column shows minimum complexity parameter tree corresponding number splits. example set cp value number 0.07843 0.05882, pruning, subtree 5 splits:","code":"library(rpart) head(kyphosis) #>   Kyphosis Age Number Start #> 1   absent  71      3     5 #> 2   absent 158      3    14 #> 3  present 128      4     5 #> 4   absent   2      5     1 #> 5   absent   1      4    15 #> 6   absent   1      2    16 kmod <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis, cp = 0, minsplit = 2) library(annotreer) annotree(kmod, show_classes = TRUE) annotree(kmod, show_classes = TRUE, show_leaf_dev = TRUE) kmod$cptable #>        CP nsplit rel error xerror   xstd #> 1 0.17647      0    1.0000  1.000 0.2156 #> 2 0.11765      1    0.8235  1.118 0.2243 #> 3 0.07843      2    0.7059  1.118 0.2243 #> 4 0.05882      5    0.4706  1.118 0.2243 #> 5 0.02941     10    0.1765  1.118 0.2243 #> 6 0.00000     16    0.0000  1.118 0.2243 annotree(prune(kmod, cp = .06), main = \"Pruned with cp = .06\")"},{"path":"https://jtr13.github.io/annotreer/index.html","id":"how-the-cptable-is-created","dir":"","previous_headings":"","what":"How the cptable is created","title":"What the Package Does (One Line, Title Case)","text":"understand rpart() created ’ll start definitions: branch includes internal node descendants. Pruning branch refers removing descendants node, .e. collapsing root node branch. subtree refers original tree pruning. algorithm pruning classification tree begins calculating deviance reduction per split internal nodes large tree. context, deviance means misclassified cases, differs tree growing process Gini index, number misclassified, used determine next optimal split. CP values table scaled version g(t)g(t), cost complexity value, direct measure misclassification reduction per split. example, takes two splits reduce number misclassified one, g(t)g(t) equal 0.5. ’ll work terms g(t)g(t) since ’s intuitive, return CP later . formally, internal nodes tree, g(t)=R(t)−R(Tt)|T̃t|−1,g(t) = \\frac{R(t) - R(T_t)}{|\\tilde{T}_t| - 1}, tt node decision tree, TtT_t subtree rooted node tt, including tt descendants, T̃t\\tilde{T}_t set terminal (leaf) nodes subtree TtT_t, R(t)R(t) risk node tt, case, deviance misclassified cases, R(Tt)R(T_t) total risk subtree TtT_t, meaning sum risks terminal nodes TtT_t, |T̃t||\\tilde{T}_t| number terminal nodes (leaves) subtree TtT_t,. Less formally ’s misclassification reduction per split, , g(t)g(t) = (difference deviance node tt sum deviance node tt’s leaf descendents) / (number splits branch tt) example, let’s consider branch root node 22 original large tree. : deviance branch: 0 (sum misclassified leaf nodes) deviance node: 2 (misclassified node) number splits branch: 4 (nodes 22, 44, 89, 45) Thus g(t)=2−04=0.5g(t) = \\frac{2 - 0}{4} = 0.5 , takes 4 splits reduce deviance 2 0, averages 0.5 reduction per split. tree displays g(t)g(t) branches:  setting show_min TRUE can add “*minimum” labels node(s) minimum value g(t)g(t). Adding show_pruned changes color nodes descendents:  weakest links g(t)=0.5g(t) = 0.5. rpart scaled root node error 1, accomplished dividing values g(t) deviance root node. case 17, scaled complexity parameter (henceforth, cp) 0.5/17 = 0.0294. redraw tree scaled values changing show_gt = TRUE show_cp = TRUE:  save space, henceforth show scaled values. determine next threshold need recalculate g(t)g(t) cp. necessary pruning tree changes cost reductions remaining nodes. set cp value slightly minimum; choose .03.  continue way tree reduced single node:     Note weakest links trees correspond values cptable. replicated process original tree successively pruned new weakest link: , table shows minimum CP value particular number splits. (Due rounding display, actual number may slightly higher.) rel error displays sum misclassified cases tree size indicated divided misclassified cases root node (nsplit = 0) ensure rel error tree splits one. case : corresponds misclassified cases trees shown .","code":"annotree(kmod, show_classes = FALSE, show_gt = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE) annotree(kmod, show_classes = FALSE, show_gt = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE,           show_min = TRUE, show_pruned = TRUE) annotree(kmod, show_classes = FALSE, show_cp = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE,           show_min = TRUE, show_pruned = TRUE) kmod2 <- prune(kmod, cp = .03) annotree(kmod2, show_classes = FALSE, show_cp = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE,           show_min = TRUE, show_pruned = TRUE) kmod3 <- prune(kmod2, cp = .06) annotree(kmod3, show_classes = FALSE, show_cp = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE,           show_min = TRUE, show_pruned = TRUE) kmod4 <- prune(kmod3, cp = .08) annotree(kmod4, show_classes = FALSE, show_cp = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE,           show_min = TRUE, show_pruned = TRUE) kmod5 <- prune(kmod4, cp = .12) annotree(kmod5, show_classes = FALSE, show_cp = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE,           show_min = TRUE, show_pruned = TRUE) kmod6 <- prune(kmod5, cp = .18) annotree(kmod6, show_classes = TRUE, show_cp = TRUE,          show_leaf_dev = TRUE, show_internal_dev = TRUE,           show_min = TRUE, show_pruned = TRUE) kmod$cptable #>        CP nsplit rel error xerror   xstd #> 1 0.17647      0    1.0000  1.000 0.2156 #> 2 0.11765      1    0.8235  1.118 0.2243 #> 3 0.07843      2    0.7059  1.118 0.2243 #> 4 0.05882      5    0.4706  1.118 0.2243 #> 5 0.02941     10    0.1765  1.118 0.2243 #> 6 0.00000     16    0.0000  1.118 0.2243 data.frame(nsplit = kmod$cptable[, \"nsplit\"],            misclassified = 17*kmod$cptable[, \"rel error\"]) #>   nsplit misclassified #> 1      0            17 #> 2      1            14 #> 3      2            12 #> 4      5             8 #> 5     10             3 #> 6     16             0"},{"path":"https://jtr13.github.io/annotreer/index.html","id":"choosing-the-cp-value","dir":"","previous_headings":"","what":"Choosing the cp value","title":"What the Package Does (One Line, Title Case)","text":"xerror xstd refer ","code":""},{"path":"https://jtr13.github.io/annotreer/reference/annotree.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Annotated Labels for rpart Trees — annotree","title":"Create Annotated Labels for rpart Trees — annotree","text":"Generates custom labels node rpart classification tree aid understanding CART's pruning algorithm","code":""},{"path":"https://jtr13.github.io/annotreer/reference/annotree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Annotated Labels for rpart Trees — annotree","text":"","code":"annotree(   mod,   show_classes = TRUE,   show_gt = FALSE,   show_cp = FALSE,   show_pruned = FALSE,   show_min = FALSE,   show_leaf_dev = FALSE,   show_internal_dev = FALSE,   main = NULL )"},{"path":"https://jtr13.github.io/annotreer/reference/annotree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Annotated Labels for rpart Trees — annotree","text":"mod rpart object show_classes logical. TRUE show class labels counts. Defaults TRUE. show_gt logical. TRUE g(t) term (misclassification reduction per split) included. Defaults FALSE. show_cp logical. TRUE complexity parameter (cp) value, calculated g(t) divided root node deviance included. Defaults FALSE. show_pruned logical. TRUE nodes slated pruning plotted distinct color. Defaults FALSE. show_min logical. TRUE node minimum g(t) labeled \"*minimum\". Defaults FALSE. show_leaf_dev logical. TRUE leaves labeled \"dev\" (misclassified cases). Defaults FALSE. show_internal_dev logical. TRUE internal nodes labeled \"dev\" (misclassified cases). Defaults FALSE. main optional title plot.","code":""},{"path":"https://jtr13.github.io/annotreer/reference/annotree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Annotated Labels for rpart Trees — annotree","text":"function primarily used create informative labels internal nodes leaves classification trees. leaf nodes, displays word \"leaf\" node's deviance. internal nodes, can display g(t) equation, cp value, optionally indicate node smallest g(t).","code":""},{"path":"https://jtr13.github.io/annotreer/reference/annotree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Annotated Labels for rpart Trees — annotree","text":"","code":"library(rpart) kmod <- rpart(Kyphosis ~ Age + Number + Start, data = kyphosis, cp = 0, minsplit = 2) annotree(kmod)"},{"path":"https://jtr13.github.io/annotreer/reference/annotreer-package.html","id":null,"dir":"Reference","previous_headings":"","what":"annotreer: What the Package Does (One Line, Title Case) — annotreer-package","title":"annotreer: What the Package Does (One Line, Title Case) — annotreer-package","text":"package (one paragraph).","code":""},{"path":[]},{"path":"https://jtr13.github.io/annotreer/reference/annotreer-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"annotreer: What the Package Does (One Line, Title Case) — annotreer-package","text":"Maintainer: First Last first.last@example.com","code":""}]
